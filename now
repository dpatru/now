#!/usr/local/bin/perl

use strict;
use v5.10; # allows use of say
use Getopt::Long qw(GetOptions);
use Pod::Usage qw(pod2usage);
use Time::Piece;
use Data::Dumper;
use File::HomeDir;
use Time::Seconds;
use Scalar::Util qw(looks_like_number);

sub getNowfile {
  my $f = glob $ENV{NOW_FILE};
  return $f if -e $f;
  $f = File::HomeDir->my_home . "/Dropbox/.now";
  return $f if -e $f;
  $f = File::HomeDir->my_home . "/.now";
  return $f if -e $f;
  my $d = File::HomeDir->my_home . "/Dropbox";
  return "$d/.now" if -d $d;
  $d = File::HomeDir->my_home;
  return "$d/.now" if -d $d;
};

# my %opts = (f=>getNowfile, breakword=>getBreakword);
my %opts = (f=>getNowfile);

## Parse options and print usage if there is a syntax error,
## or if usage was explicitly requested.

# say Dumper(\%opts);
# say "Argv is " . join ' ', @ARGV;

Getopt::Long::Configure ("bundling");
GetOptions(\%opts,
	   'h|?', 'help|man', 'version', 'verbose|v',
	   'hours', 'minutes', 'hours-minutes',
	   'silent|s', 'nobreak', 'breakword=s@',
	   'estimates',
	   't=i', 'w=i', 'd=i', 'y=i', 'f=s'
	  )
  or pod2usage(2);
# say Dumper(\%opts);

sub setBreakword {
  my @breakwords;
  unshift @breakwords, split / *, */ for @{$opts{breakword}};
  # say @breakwords . " breakwords from command line: " . join ',', @breakwords;

  if (!@breakwords) {
    @breakwords = split / *, */, $ENV{NOW_BREAK_WORD} if !@breakwords;
    # say @breakwords . " breakwords from environment: " . join ',', @breakwords;
  }

  if (!@breakwords) {
    @breakwords = ( "break" );
    # say @breakwords . " breakwords as default: " . join ',', @breakwords;
  }

  $opts{breakword} = \@breakwords;
};

setBreakword;
# say "breakword = @{$opts{breakword}}";


pod2usage(-verbose => 1) if $opts{h};
pod2usage(-verbose => 2) if $opts{help};

if ($opts{version}) {
  say "This is now version 1. ";
  exit(0);
}
    

pod2usage("$0: options t, w, and d accept only non-negative integers.")
  if $opts{t} < 0 || $opts{d} < 0 || $opts{w} < 0;

# say "Argv is " . join ' ', @ARGV;

sub timestamp {
  my $t = localtime;
  return $t->date . ' ' . $t->time;
}
# say timestamp();

sub parseTimestamp { # return a gmt of the localtime timestamp
  use Try::Tiny;
  my $s = shift(@_);
  try {
    my $t = Time::Piece->strptime($s, "%Y-%m-%d %T");
    $t -= localtime->tzoffset; # convert to gmt
    # say "parseTimestamp($s) = $t ";
    return $t;
  } catch {
    say "parseTimestamp: caught error $_";
    return 0;
  } 
}

# say parseTimestamp("2016-12-16 15:06:07");

my ($t1, $t2);

sub parseLine {
  my ($t2, $line) = @_;
  if (my($timestamp, $est, $task) = $line =~ /(\d+\-\d+\-\d+ \d+:\d+:\d+) ?(\d*) (.*)/) {
    my $t1 = parseTimestamp($timestamp);
    if ($t1) {
      my $et = sprintf("%.2f", ($t2 - $t1)/3600.0);
      return ($t1, $et, $est, $task);
      }}
  return ();
};

sub addToTree {
  my ($tree, $et, @categories) = @_;
  for (@categories) {
    if (exists $tree->{$_}) {$tree = $tree->{$_};}
    else {$tree = $tree->{$_} = {};}
  }
  $tree->{''} += $et;
};

sub printHours {
  my ($hours, $est)= @_;
  
  my $output = '';
  if ($opts{"hours-minutes"}) {
    $output .= sprintf("%6d:%02d", int($hours), ($hours - int($hours))*60.0);
    $output .= sprintf("/%6d:%02d", int($est), ($est - int($est))*60.0) if $opts{estimates};
    $output .= " ";
    
  }
  if ($opts{minutes}) {
    $output .= sprintf("%10.0f min", $hours * 60.0);
    $output .= sprintf("/%10.0f min", $est * 60.0) if $opts{estimates};
    $output .= " ";
  }
  if ($opts{hours} or !$output) {
    $output .= sprintf("%8.2f hrs", $hours);
    $output .= sprintf("/%8.2f hrs", $est) if $opts{estimates};
    $output .= " ";
  }
  return $output;
};

      
my @output_lines; # this needs to be global, declaring it inside printReport gives scoping errs.
sub printReport {
  my $r = shift(@_);
  # say "printReport " . Dumper($r);
  @output_lines = (); # reset output lines
  sub _p {
    # my ($level, $r) = @_;
    my ($prefix, $suffix, $r) = @_;
    @_ = ();
    my $sum = 0;
    # say "level = $level: " . Dumper($r);
    my @sorted_keys = reverse sort keys %{ $r };
    for my $k ( @sorted_keys ) {
      if (ref($r->{$k}) eq 'HASH') {
	if (scalar keys %{ $r->{$k} } == 1 and exists $r->{$k}->{''}) {
	  # say "Leaf category, printing hours for $suffix $k";
	  # my $t = sprintf("%8.2f", $r->{$k}->{''});
	  unshift @output_lines, "$prefix         " . printHours($r->{$k}->{''}) . "$suffix $k";
	  $sum += $r->{$k}->{''};
	} else {
	  # say "Aggregate category, find totals and print summary for $suffix $k";
	  my $total = _p("$prefix", "$suffix $k:", $r->{$k});
	  # my $t = sprintf("%8.2f", $total);
	  unshift @output_lines, "$prefix ". printHours($total) . "(total) $suffix $k";
	  $sum += $total;
	}
      } else {
	# say "True leaf, print hours for $suffix $k";
	# my $t = sprintf("%8.2f", $r->{$k});
	unshift @output_lines, "$prefix         " . printHours($r->{$k}) . "$suffix $k";
	$sum += $r->{$k};
      }
    }
    return $sum;
  };
  # _p(0, $r);
  for my $k (reverse sort keys %{ $r }) {
    my $t = sprintf("%8.02f", _p($k, "", $r->{$k}));
    unshift @output_lines, "\n$k $t hrs (total)";
  }
  say for @output_lines;
};

sub getVelocities { # get some velocities to simulate with
  # use the n most recent
  my $n = 1000;
  
  use File::ReadBackwards ;
  # Tied Handle Interface
  my ($t2, $et, $est, $task);
  $t2 = localtime;
  my @velocities;
  tie *BW, 'File::ReadBackwards', $opts{f} or
    die "can't read .now file ($opts{f}) $!" ;
  while( <BW> ) {
    chomp;
    if (($t2, $et, $est, $task) = parseLine($t2, $_) and $est) {
      unshift @velocities, 1.0 * $et / $est;
      last if $n-- <= 0;
    }}
  return @velocities;
}

if (@ARGV > 0) { # option parser remove options from @ARGV, check what's left
  # say "there are still arguments: " . join ', ', @ARGV;
  if ( (grep { looks_like_number($_) } @ARGV) == @ARGV ) { # test lengths
    # say "all args are numbers - Simulate";
    say "Simulating . . . ";
    my @velocities = getVelocities();
    # say "velocities = " . join ',', @velocities;
    
    my @times;
    my $n = 100;
    while ($n-- > 0) {
      my $t = 0;
      for (@ARGV) { $t += $_ * $velocities[rand @velocities]; }
      unshift @times, sprintf("%6.0f", $t);
    }
    my $i = 5;
    say "     5%     15%     25%     35%     45%     55%     65%     75%     85%     95%";
    say join ', ', grep { not ( $i++ % 10 ) } sort { $a <=> $b } @times;
  } else {
    # say "NOT all args are numbers - Add a task";
    my $task = join ' ', @ARGV;
    if (!$opts{silent}) {
      my $n = 10;
      say "adding task $task, the last $n tasks in $opts{f} are:\n";
      $opts{t} = $n if (!$opts{t});
    }
    open(my $fh, '>>', $opts{f}) or die "Could not open file '$opts{f}' $!";
    say $fh timestamp() . " " . $task;
    close $fh; 
  }
}

if ($opts{t} || $opts{d} || $opts{w} || $opts{y}) { # print report of tasks
  use File::ReadBackwards ;
  # Tied Handle Interface

  if ($opts{t}) { # task report
    $t2 = localtime;
    my @output_lines;
    tie *BW, 'File::ReadBackwards', $opts{f} or
      die "can't read .now file ($opts{f}) $!" ;

    while( <BW> ) {
      chomp;
      if (my ($t2, $et, $est, $task) = parseLine($t2, $_)) {
	say "$t2, $et, $est, $task";
	unshift @output_lines, "$t2 for ".printHours($et)." $task";
	last if $opts{t}-- <= 0;
      }}
    say for @output_lines;
  }

  if ($opts{d}) { # daily report
    # say "daily";
    generate_report("date", $opts{d});
  }
  if ($opts{w}) { # weekly report
    # say "weekly";
    generate_report(sub {
		      my $t = $_[0];
		      return $t->year . " week " . $t->week . " beginning " .
			    ($t - $t->_wday * ONE_DAY)->date; },
		    $opts{w});
  }
  if ($opts{y}) { # yearly report
    generate_report("year", $opts{y});
  }
  sub generate_report {
    my ($field, $n) = @_;
    my @processed_lines; # store processed lines here for verbose option

    # say "$t2->$field";
    # say $t2->$field;
    # say $t2->$field();
    # #say $field($t2);
    # say $field->($t2);
    
    my %report;
    tie *BW, 'File::ReadBackwards', $opts{f} or
      die "can't read .now file ($opts{f}) $!" ;
    my $t2 = gmtime;
    while( <BW> ) {
      chomp;
      # $t2 = gmtime if $breakflag;
      if (my ($nextt2, $et, $est, $task) = parseLine($t2, $_)) {
	if ($opts{verbose}) { unshift @processed_lines, "$t2 $et $est $task"; }
	$t2 = $nextt2;

	# if we're processing a break, skip it.
	next if !$opts{nobreak} and grep /^$task$/, @{$opts{breakword}};
	
	my $r;
	if (exists $report{$t2->$field}) {
	  $r = $report{$t2->$field};
	  # say $t2->$field . " exists.";

	} else {
	  # say $t2->$field . " does not exist.";
	  last if $n-- <= 0;
	  $r = $report{$t2->$field} = {};
	}
	my @categories = split /\s*:+\s*/, $task;
	addToTree( $r, $et, @categories );
	# say Dumper(\%report);
      }}
    if ($opts{verbose}) { say for @processed_lines; say ""; }
    printReport(\%report);
  }
}



__END__

=head1 now

now prog: docs      # Add task "prog: docs" to .now file.

now 12 prog: plan   # Add task "prog: plan" with estimate 12 minutes.

now                 # Print report.

now -t 4            # Print report of the last 4 tasks

now -d 4            # Print report of the last 4 days.

now -w 4            # Print report of the last 4 weeks.

now 5               # Estimate duration of task estimated to be 5 minutes.

now 5 10 3          # Estimate the duration of tasks estimated to be 
                    # 5, 10, and 3 minutes.

sample - Using GetOpt::Long and Pod::Usage

=head1 SYNOPSIS

sample [options] [file ...]

 Options:
   -h|?              brief help message
   --help | --man    full documentation
   --version         print version and exit
   --verbose | -v    print processed lines before reports
   --hours           print report in hours (default)
   --minutes         print report in minutes instead of hours
   --hours-minutes   print report in hours and minutes instead of hours
   --nobreak         do not skip breaks
   --breakword stop  use "stop" as the breakword instead of "break".
   --estimates       show estimates when reporting
   -f mynowfile      use now file mynowfile (default is ~/.now)
   -t 5              show 5 tosks
   -d 5              show 5 days
   -w 5              show 5 weeks

=head1 OPTIONS

=over 4

=item B<-h>

Print a brief help message and exits.

=item B<--help>

Prints the manual page and exits.

=item B<--breakword stop>

Use "stop" as the breakword instead of the default or the environment-defined breakword.
Multiple words can be defined by separating with commas or using multiple --breakword options.
The default breakword is "break".
The default breakword can be set by the environment variable "NOW_BREAK_WORD".

=back

=head1 DESCRIPTION

B<now> is a simple, text-based, shell-based time tracker suitable for 
tracking time at the terminal and completing time sheets. 
Tasks are stored in a text file ~/Dropbox/.now or ~/.now.
Tasks are stored in the .now file, one task per line, prepended by a timestamp and 
an optional estimate. You can easily edit this file by hand. This utility just 
makes common tasks easier.

B<now> has three modes of use: 
(1) real-time tracking mode, 
(2) report mode, and 
(3) estimation mode.

To use the real-time tracking mode, call B<now> with the task. 
The task will be appended the .now file with the current time.
Call B<now> with a new task, or a "break" task when the current task is done.

=over 4

now programming: finish docs # start tracking "programming: docs" now

=back

You can also add an estimate (integer). 

=over 4

now 10 my task # start tracking "my task" now, estimate 10 minutes

=back

Use the -d, -w, or -t options for report mode. This will print a report of the last n days, weeks, or tasks respectively. Colons (:) are used to mark task categories. Reports break down time spent hierachially in each category and task. The -v or --verbose option will print the tasks processed before the report.

Calling B<now> with a list of estimates will produce a time range based on past estimates in the now file. 

=head1 CUSTOMIZATION

=item B<.now>

To customize the .now file, set the NOW_FILE environment variable or use the -f flag. 
Specifically, add the following line to your ~/.profile: 

=over 4

export NOW_FILE=~/.now

=back

=item B<break


=cut
