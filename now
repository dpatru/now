#!/usr/local/bin/perl

use strict;
use v5.10; # allows use of say
use Getopt::Long qw(GetOptions);
use Pod::Usage qw(pod2usage);
use Time::Piece;
use Data::Dumper;
use File::HomeDir;
use Time::Seconds;
use Scalar::Util qw(looks_like_number);
use List::Util qw(sum);
use Carp::Assert qw(assert should);


my %opts = ();

sub saydebug {
  say "DEBUG: " . (join ' ', @_) if $opts{DEBUG};
};


if (@ARGV == 0) {
  say "The last few tasks are . . .";
  $opts{t}=10;
}

## Parse options and print usage if there is a syntax error,
## or if usage was explicitly requested.

# say Dumper(\%opts);
# say "Argv is "

Getopt::Long::Configure ("bundling");
GetOptions(\%opts,
	   'h|?', 'help|man', 'version', 'verbose|v',
	   'hours', 'minutes', 'hours-minutes',
	   'silent|s', 'nobreak', 'breakword=s@',
	   'estimates', 'noestimates',
	   'sunday', 'monday',
	   'DEBUG', 'NODEBUG',
	   'samples=i', 'tries=i',
	   't=i', 'w=i', 'd=i', 'y=i', 'f=s'
	  )
  or pod2usage(2);
# say Dumper(\%opts);

pod2usage(-verbose => 1) if $opts{h};
pod2usage(-verbose => 2) if $opts{help};

if ($opts{version}) {
  say "This is now version 1. ";
  exit(0);
}

pod2usage("$0: options t, w, and d accept only non-negative integers.")
  if $opts{t} < 0 || $opts{d} < 0 || $opts{w} < 0;

sub setOption {
  my ($option, $nooption, $env, $default) = @_;
  if ($opts{$option}) {
    saydebug "$option set by commandline";
    return;
  }
  elsif ( $opts{$nooption} ) {
    $opts{$option} = 0;
    saydebug "$option unset by commandline";
    return;
  }
  elsif ( exists $ENV{$env} ) {
    $opts{$option} = $ENV{$env};
    saydebug "$option set by environment to $ENV{$env}";
  }
  else {
    $opts{$option} = $default;
    saydebug "$option set by $default by default.";
  }
};

setOption("DEBUG", "NODEBUG", "NOW_DEBUG", 0);
setOption("estimates", "noestimates", "NOW_ESTIMATES", 0);
setOption("verbose", "noverbose", "NOW_VERBOSE", 0);
setOption("sunday", "monday", "NOW_SUNDAY", 0);
setOption("samples", "n/a", "NOW_SAMPLES", 50);
setOption("tries", "n/a", "NOW_TRIES", 1000);
  
sub setNowfile {
  if ($opts{f}) { 
    saydebug "nowfile set by commandline";
    return;
  }
  elsif ( -e (glob $ENV{NOW_FILE} )) {
    $opts{f} = $ENV{NOW_FILE};
    saydebug "nowfile set by environment to $ENV{NOW_FILE}";
    return;
  }
  my $f = File::HomeDir->my_home . "/Dropbox/.now";
  $f = File::HomeDir->my_home . "/.now" if not -e $f;
  if ( -e $f ) {
    $opts{f} = $f;
    saydebug "nowfile set to $f by default.";
    return;
  }
  my $d = File::HomeDir->my_home . "/Dropbox";
  $d = File::HomeDir->my_home if not -d $d;
  $opts{f} = "$d/.now";
  saydebug "nowfile set to $opts{f} by default.";
}

setNowfile;

sub setBreakword {
  my @breakwords;
  if ($opts{breakword}) { 
    unshift @breakwords, split / *, */ for @{$opts{breakword}};
    $opts{breakword} = \@breakwords;
    saydebug @breakwords . " breakwords from command line: " . join ',', @breakwords;
    return;
  }
  elsif (exists $ENV{NOW_BREAK_WORD}) {
    if ($ENV{NOW_BREAK_WORD}) {
      @breakwords = split / *, */, $ENV{NOW_BREAK_WORD};
      $opts{breakword} = \@breakwords;
      saydebug @breakwords . " breakwords from environment: " . join ',', @breakwords;
      return;
    }
    else {
      saydebug @breakwords . " breakwords from environment.";
    }
  }
  else {
    @breakwords = ( "break", "stop" );
    $opts{breakword} = \@breakwords;
    saydebug @breakwords . " breakwords as default: " . join ',', @breakwords;
    return;
  }
};
setBreakword;

# say "Argv is " . join ' ', @ARGV;

sub timestampnow {
  my $t = Time::Piece->new;
  return timestamp($t);
}

sub timestamp {
  my $t = shift @_;
  return $t->date . ' ' . $t->time;
};
# say timestamp();

sub parseTimestamp { # return a gmtime of timestamp
  use Try::Tiny;
  my $s = shift(@_);
  my $t;
  try {
    $t = Time::Piece->strptime($s, "%Y-%m-%d %T");
    # $t += localtime->tzoffset; # convert to localtime
  } catch {
    say "parseTimestamp: caught error $_";
    return 0;
  };
  # saydebug "\nparseTimestamp($s) = $t = " . timestamp($t) . "\n";
  should($s, timestamp($t));
  return $t;
}

# saydebug parseTimestamp("2016-12-16 15:06:07");

my ($t1, $t2);

sub toHours {
  my $t = shift @_;
  if ($t =~ /(\d*\.?\d*):(\d*\.?\d*):?(\d*)/) {
    my $h = $1 + $2/60.0 + $3/3600;
    # say "converting h:m:s $t to hours $h";
    return $h;
  }
  return $t;
};
  
sub parseLine {
  my ($t2, $line) = @_;
  if (my($timestamp, $est, $task) = $line =~ /(\d+\-\d+\-\d+ \d+:\d+:\d+)\s*(\d+.?\d*|\.\d+|\d*:\d+:?\d*)?\s+(.*)/) {
    my $t1 = parseTimestamp($timestamp);
    if ($t1) {
      my $et = sprintf("%.2f", ($t2 - $t1)/3600.0);
      $est = toHours $est;
      my @result = ($t1, $et, $est, $task);
      # saydebug "parseline(" . timestamp($t2) . ", $line)->(". (join ', ', @result) . ")";
      return @result;
    }}
  saydebug "parseline(" . join(', ', @_) . ")->()";
  return ();
};

sub formatLine {
  my ($t, $et, $est, $task) = @_;
  sprintf("%s %5.2f %5.2f %s", timestamp($t), $et, $est, $task);
};

sub formatLine_header {
  return "date  time  duration estimate task";
};
    


sub addToTree {
  my ($tree, $et, @categories) = @_;
  # saydebug "addToTree: " . join ', ', @{$et};
  for (@categories) {
    if (exists $tree->{$_}) {$tree = $tree->{$_};}
    else {$tree = $tree->{$_} = {};}
  }
  $tree->{''} = $et; # $et can be a list or o scalar.
};

my $hourDigits = 8;
sub printHours {
  my $arg = shift @_;
  my ($hours, $est)= @{$arg};
  my $output = '';
  if ($opts{"hours-minutes"}) {
    $output .= sprintf("%${hourDigits}d:%02d", int($hours), ($hours - int($hours))*60.0);
    if ($opts{estimates}) {
      if ($est) {
	$output .= sprintf("/%${hourDigits}d:%02d", int($est), ($est - int($est))*60.0);
      }
      else {
	my $f = $hourDigits + 3;
	$output .= sprintf("/%${f}s", "");
      }
    }
    $output .= " ";
    
  }
  if ($opts{minutes}) {
    my $minuteDigits = $hourDigits + 2;
    my $m = $hours * 60.0;
    $output .= sprintf("%${minuteDigits}.0fm", $hours * 60.0);
    if ($opts{estimates}) {
      if ($est) {
	$output .= sprintf("/%${minuteDigits}.0fm", $est * 60.0);
      }
      else {
	$output .= sprintf("/%${minuteDigits}s ", "");
      }
    }
    $output .= " ";
  }
  if ($opts{hours} or !$output) {
    my $dhourDigits = $hourDigits + 3;
    $output .= sprintf("%${dhourDigits}.2fh", $hours);
    if ($opts{estimates}) {
      if ($est) {
	$output .= sprintf("/%${dhourDigits}.2fh", $est);
      }
      else {
	$output .= sprintf("/%${dhourDigits}s ", "");
      }
    }
    $output .= " ";
  }
  return $output;
};

sub formatReportTotal {
  my ($t, $et, $task) = @_;
  return "$t " . printHours($et) . "$task";
};

sub formatReportItem {
  # $t is a string, $et is as printHours expects, $task is a string
  my ($t, $et, $task) = @_;
  return "$t " . printHours($et) . "$task";
};
  
my @output_lines; # this needs to be global, declaring it inside printReport gives scoping errs.
sub printReport {
  my $r = shift @_;
  # saydebug "printReport " . Dumper($r);
  @output_lines = (); # reset output lines
  sub _p {
    # my ($level, $r) = @_;
    my ($prefix, $suffix, $r) = @_;
    @_ = ();
    my $sum = 0;
    my $estsum = 0;
    # saydebug "level = $level: " . Dumper($r);
    my @sorted_keys = reverse sort keys %{ $r };
    for my $k ( @sorted_keys ) {
      if (ref($r->{$k}) eq 'HASH') {
	if (scalar keys %{ $r->{$k} } == 1 and exists $r->{$k}->{''}) {
	  # saydebug "Leaf category, printing hours for $suffix $k";
	  unshift @output_lines, formatReportItem($prefix, $r->{$k}->{''}, "$suffix$k");
	  $sum += ${$r->{$k}->{''}}[0];
	  $estsum += ${$r->{$k}->{''}}[1];
	  # saydebug "constructed leaf: sum = $sum, estsum = $estsum";
	} else {
	  # saydebug "Aggregate category, find totals and print summary for $suffix $k";
	  my $total = _p("$prefix", "$suffix$k: ", $r->{$k});
	  unshift @output_lines, formatReportTotal($prefix, $total, "(total) $suffix$k");
	  $sum += ${$total}[0];
	  $estsum += ${$total}[1];
	  # saydebug "aggregate: sum = $sum, estsum = $estsum";
	}
      } else {
	# saydebug "True leaf, print hours for $suffix $k";
	# my $t = sprintf("%8.2f", $r->{$k});
	unshift @output_lines, formatReportItem($prefix, $r->{$k}, "$suffix$k");
	$sum += ${$r->{$k}}[0];
	$estsum += ${$r->{$k}}[1];
	# saydebug "leaf: sum = $sum, estsum = $estsum";
      }
    }
    return [$sum, $estsum];
  };
  # _p(0, $r);
  for my $k (reverse sort keys %{ $r }) {
    my $t = _p($k, "", $r->{$k});
    unshift @output_lines, "\n$k ". printHours($t) . "(total)";
  }
  say for @output_lines;
};

sub getVelocities { # get some velocities to simulate with
  # use the n most recent
  my $n = shift @_ || 1000;
  say "getting $n velocities . . ." if $opts{verbose};
  
  use File::ReadBackwards ;
  # Tied Handle Interface
  my ($t2, $et, $est, $task);
  $t2 = gmtime; $t2 += localtime->tzoffset;
  my @velocities;
  tie *BW, 'File::ReadBackwards', $opts{f} or
    die "can't read .now file ($opts{f}) $!" ;
  while( <BW> ) {
    chomp;
    if (($t2, $et, $est, $task) = parseLine($t2, $_) and $est) {
      unshift @velocities, $et * 1.0 / $est;
      last if $n-- <= 0;
    }}
  say "got " . ($#velocities + 1) . " velocities" if $opts{verbose};
  return @velocities;
};

sub simulate {
  my ($sample, $tries, @estimates) = @_;
  my @te = map {sprintf("%.2f", $_)} @estimates; # truncated estimates for printing
  if (@estimates > 1) { 
    say "Simulating tasks of " . join(', ', @te). " = " .
      sum(@te) . " total, printing percentiles . . . ";
  }
  else {
    say "Simulating task of $te[0], printing percentiles . . . ";
  }
  my @velocities = getVelocities $sample;
  # say "velocities = " . join ',', @velocities;
  
  my @times;
  my $n = $tries;
  while ($n-- > 0) {
    my $t = 0;
    for (@estimates) { $t += 1.0 * $_ * $velocities[rand @velocities]; }
    unshift @times, $t;
  }
  say "     5%     15%     25%     35%     45%     55%     65%     75%     85%     95%";
  my $step = $tries / 10.0;
  my @stimes = sort { $a <=> $b } @times;
  say join ' ', map { sprintf("%7.0f", $stimes[$step * ($_ + .5)]) } (0..9);
};


if (@ARGV > 0) { # option parser remove options from @ARGV, check what's left
  # say "there are still arguments: " . join ', ', @ARGV;
  if ( (grep { looks_like_number($_) or /^\d*:\d*:?\d*$/ } @ARGV) == @ARGV ) { # test lengths
    # say "all args are numbers - Simulate";
    my @hours = map {toHours $_} @ARGV;
    # say join ', ', @hours;
    simulate($opts{samples}, $opts{tries}, @hours);
  }
  else {
    # say "NOT all args are numbers - Add a task";
    my $task = join ' ', @ARGV;
    if (!$opts{silent}) {
      say "starting $task"
    }
    open(my $fh, '>>', $opts{f}) or die "Could not open file '$opts{f}' $!";
    say $fh timestampnow() . " " . $task;
    close $fh; 
  }
}

if ($opts{t} || $opts{d} || $opts{w} || $opts{y}) { # print report of tasks
  use File::ReadBackwards ;
  # Tied Handle Interface

  if ($opts{t}) { # task report
    $hourDigits = 2;
    my ($t1, $t2, $et, $est, $task);
    $t2 = gmtime; $t2 += localtime->tzoffset;
    # say "first t2 = $t2 = ". timestamp($t2) if $opts{DEBUG};
    my @output_lines = ();
    tie *BW, 'File::ReadBackwards', $opts{f} or
      die "can't read .now file ($opts{f}) $!" ;
    while( <BW> ) {
      chomp;
      # say "task report processing line: $_" if $opts{DEBUG};
      if (($t1, $et, $est, $task) = parseLine($t2, $_)) {
	# say "task report: " . timestamp($t1) . "=t1=$t1, $et, $est, $task - ". timestamp($t1)  if $opts{DEBUG};
	my $line = formatReportItem(timestamp($t1), [$et,$est], $task);
	$t2 = $t1;
	next if !$opts{nobreak} and grep /^$task$/, @{$opts{breakword}};
	# say $line if $opts{DEBUG};
	unshift @output_lines, $line;
	last if --$opts{t} <= 0;
      }}
    say for @output_lines;
  }

  sub generateReport {
    my ($field, $n) = @_;
    my @processed_lines; # store processed lines here for verbose option
    my %report;
    tie *BW, 'File::ReadBackwards', $opts{f} or
      die "can't read .now file ($opts{f}) $!" ;
    my $t2 = gmtime; $t2 += localtime->tzoffset;
    while( <BW> ) {
      chomp;
      if (my ($nextt2, $et, $est, $task) = parseLine($t2, $_)) {
	if ($opts{verbose}) {
	  unshift @processed_lines, formatLine($t2, $et, $est, $task);
	}
	$t2 = $nextt2;
	# if we're processing a break, skip it.
	next if !$opts{nobreak} and grep /^$task$/, @{$opts{breakword}};
	my $r;
	if (exists $report{$t2->$field}) {
	  $r = $report{$t2->$field};
	  # say $t2->$field . " exists.";
	}
	else {
	  # say $t2->$field . " does not exist.";
	  last if $n-- <= 0;
	  $r = $report{$t2->$field} = {};
	}
	my @categories = split /\s*:+\s*/, $task;
	addToTree( $r, [$et, $est], @categories );
	# say Dumper(\%report);
      }}
    if ($opts{verbose}) {
      say "processed $#processed_lines lines";
      say for @processed_lines;
    }
    # say Dumper(\%report);
    
    printReport(\%report);
  }

  if ($opts{d}) { # daily report
    # say "daily";
    $hourDigits = 2;
    generateReport("date", $opts{d});
  }
  if ($opts{w}) { # weekly report
    # say "weekly";
    $hourDigits = 3;
    generateReport(\&getWeek, $opts{w});
  }
  if ($opts{y}) { # yearly report
    $hourDigits = 4;
    generateReport("year", $opts{y});
  }
};

sub getWeek {
  # http://perldoc.perl.org/Time/Piece.html#Week-Number: The week
  # number may be an unknown concept to some readers. The ISO 8601
  # standard defines that weeks begin on a Monday and week 1 of the
  # year is the week that includes both January 4th and the first
  # Thursday of the year. In other words, if the first Monday of
  # January is the 2nd, 3rd, or 4th, the preceding days of the January
  # are part of the last week of the preceding year. Week numbers
  # range from 1 to 53.
  #
  # Allow the option to start the week on Sunday, but keep the week number the same.
  my $t = shift @_;
  
  # If it's Sunday, then bump up the time to Monday so that the week number is correct.
  my $t2 = $opts{sunday} && $t->_wday == 0? $t + * ONE_DAY: $t;

  my $firstday = $opts{sunday}? $t - $t->_wday * ONE_DAY:
    $t - ($t->_wday - 1)*ONE_DAY;

  my $r = $t2->year . " week " . $t2->week . " beginning " .
    $firstday->wdayname . " " . $firstday->date;
  return $r;
};
      


__END__

=head1 now EXAMPLES

B<now prog: docs>      # Add task "prog: docs" to .now file.

B<now 12 prog: plan>   # Add task "prog: plan" with estimate 12 minutes.

B<now>                 # Print report.

B<now -t 4>            # Print report of the last 4 tasks

B<now -d 4>            # Print report of the last 4 days.

B<now -w 4>            # Print report of the last 4 weeks.

B<now 5>               # Estimate duration of task estimated to be 5 minutes.

B<now 5 10 3>          # Estimate the duration of tasks estimated to be 
                    # 5, 10, and 3 hours.

sample - Using GetOpt::Long and Pod::Usage

=head1 SYNOPSIS

sample [options] [file ...]

 Options:
   -h|?              brief help message
   --help | --man    full documentation
   --version         print version and exit
   --verbose | -v    print processed lines before reports
   --hours           print report in hours (default)
   --minutes         print report in minutes instead of hours
   --hours-minutes   print report in hours and minutes instead of hours
   --nobreak         do not skip breaks
   --breakword stop  use "stop" as the breakword instead of "break".
   --estimates       show estimates when reporting
   --noestimates     turn off estimates when reporting
   --sunday          start the week on sunday for weekly reports
   --monday          start the week on monday (default)
   --samples 1000    number of sample estimates to retrieve for the simulation
   --tries 100       number of times to simulate
   -f mynowfile      use now file mynowfile (default is ~/.now)
   -t 5              show 5 tosks
   -d 5              show 5 days
   -w 5              show 5 weeks

=head1 OPTIONS

=over 4

=item B<-h>

Print a brief help message and exits.

=item B<--help>

Prints the manual page and exits.

=item B<--breakword stop,quit>

Use "stop" or "quit" as breakwords instead of the default or the
environment-defined breakword.  Multiple words can be defined by
separating with commas or using multiple --breakword options.  The
default breakword is "break".  The default breakword can be set by the
environment variable "NOW_BREAK_WORD".  

Breakwords are used to end a task without starting a new one. Breaks
are normally ignored when reporting. 

=item B<--sunday, --nosunday>

For weekly reporting, the week starts on Monday. According to 
http://perldoc.perl.org/Time/Piece.html#Week-Number: 

=over 4

The week number may be an unknown concept to some readers. The ISO
8601 standard defines that weeks begin on a Monday and week 1 of the
year is the week that includes both January 4th and the first Thursday
of the year. In other words, if the first Monday of January is the
2nd, 3rd, or 4th, the preceding days of the January are part of the
last week of the preceding year. Week numbers range from 1 to 53.

=back

Use the B<--sunday> option to start the week on Sunday for weekly
reports. The number of the week will still follow ISO 8601, but Sunday
will be treated as belonging to the following week (that starts the
next Monday.) This can also be set with the environment variable
NOW_SUNDAY=1.

=item B<--samples 1000, --tries 1000>

When simulating tasks, there are two parameters that can be
adjusted. B<samples> is the number of velocities that are pulled from
the nowfile. (A velocity is the ratio of time spent on a task divided
by the estimate. A velocity of 1 means that time went as expected. A
velocity of 2 means that time went twice as fast as expected.) The
velocities are taken in reverse order (from the bottom of the
nowfile).

Once the samples are taken, the task is simulated by multiplying the
estimates by a randomly chosen velocity. The results are then sorted
and the 5th, 15th, 25th, ..., 95th percentiles are taken. The number
of simulations is the number of B<tries>. To get a more
probabalistically accurate estimate, increase the number of
B<tries>. A smaller B<samples> ignores older velocities.

=back

=head1 DESCRIPTION

B<now> is a simple, text-based, shell-based time tracker suitable for
tracking time at the terminal and completing time sheets.  Tasks are
stored in a text file ~/Dropbox/.now or ~/.now.  Tasks are stored in
the .now file, one task per line, prepended by a timestamp and an
optional estimate (in hours). You can easily edit this file by
hand. This utility just makes common tasks easier.

B<now> has three modes of use: 
(1) real-time tracking mode, 
(2) report mode, and 
(3) estimation mode.

=head2 REAL-TIME TRACKING

To use the real-time tracking mode, call B<now> with the task.  The
task will be appended the .now file with the current time.  Call
B<now> with a new task, or a "break" task when the current task is
done.

=over 4

now programming: finish docs # start tracking "programming: docs" now

=back

You can also add an estimate (integer). 

=over 4

now 10 my task # start tracking "my task" now, estimate 10 minutes

=back

=head2 REPORTING

Use the -d, -w, or -t options for report mode. This will print a
report of the last n days, weeks, or tasks respectively. Colons (:)
are used to mark task categories. Reports break down time spent
hierachially in each category and task. The -v or --verbose option
will print the tasks processed before the report.

=head2 ESTIMATING

Calling B<now> with a list of estimates will produce a time range
based on past estimates in the now file. See evidence-based scheduling
and http://www.joelonsoftware.com/items/2007/10/26.html.

=head1 CUSTOMIZATION

You can set some options using environment variables. The following is
a sample ~/.profile.

=over 4

# set the .now file to ~/mydir/.now

export NOW_FILE=~/mydir/.now

# Treat stop, break, quit, and done as breakwords.

export NOW_BREAK_WORD=stop,break,quit,done

# Include estimates in reports.

export NOW_ESTIMATES=1

# Start weeks on Sunday.

export NOW_SUNDAY=1

# Start weeks on Monday.

export NOW_SUNDAY=0

# Set the default samples and tries.

export NOW_SAMPLES=100

export NOW_TRIES=80

=back




=cut
