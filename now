#!/usr/local/bin/perl

use strict;
use v5.10; # allows use of say
use Getopt::Long qw(GetOptions);
use Pod::Usage qw(pod2usage);
use Time::Piece;
use Data::Dumper;
use File::HomeDir;
use Time::Seconds;
use Scalar::Util qw(looks_like_number);
use List::Util qw(sum);
use Carp::Assert qw(assert should);

sub getNowfile {
  my $f = glob $ENV{NOW_FILE};
  return $f if -e $f;
  $f = File::HomeDir->my_home . "/Dropbox/.now";
  return $f if -e $f;
  $f = File::HomeDir->my_home . "/.now";
  return $f if -e $f;
  my $d = File::HomeDir->my_home . "/Dropbox";
  return "$d/.now" if -d $d;
  $d = File::HomeDir->my_home;
  return "$d/.now" if -d $d;
};

my %opts = (f=>getNowfile);

if (@ARGV == 0) {
  say "The last few tasks are . . .";
  $opts{t}=10;
}

## Parse options and print usage if there is a syntax error,
## or if usage was explicitly requested.

# say Dumper(\%opts);
# say "Argv is "

Getopt::Long::Configure ("bundling");
GetOptions(\%opts,
	   'h|?', 'help|man', 'version', 'verbose|v',
	   'hours', 'minutes', 'hours-minutes',
	   'silent|s', 'nobreak', 'breakword=s@',
	   'estimates', 'noestimates',
	   'DEBUG', 'NODEBUG',
	   't=i', 'w=i', 'd=i', 'y=i', 'f=s'
	  )
  or pod2usage(2);
# say Dumper(\%opts);

pod2usage(-verbose => 1) if $opts{h};
pod2usage(-verbose => 2) if $opts{help};

if ($opts{version}) {
  say "This is now version 1. ";
  exit(0);
}

pod2usage("$0: options t, w, and d accept only non-negative integers.")
  if $opts{t} < 0 || $opts{d} < 0 || $opts{w} < 0;


sub setOption {
  my ($option, $nooption, $env) = @_;
  if ($opts{$option}) {
    say "$option set by commandline" if $opts{DEBUG};
    return;
  }
  elsif ( $opts{$nooption} ) {
    $opts{$option} = 0;
    say "$option unset by commandline" if $opts{DEBUG};
    return;
  }
  elsif ( exists $ENV{$env} ) {
    $opts{$option} = $ENV{$env};
    say "$option set by environment to $ENV{$env}" if $opts{DEBUG};
  }
};

setOption("DEBUG", "NODEBUG", "NOW_DEBUG");
setOption("estimates", "noestimates", "NOW_ESTIMATES");
setOption("verbose", "noverbose", "NOW_VERBOSE");

  
sub setBreakword {
  my @breakwords;
  unshift @breakwords, split / *, */ for @{$opts{breakword}};
  say @breakwords . " breakwords from command line: " . join ',', @breakwords if $opts{DEBUG};

  if (!@breakwords) {
    @breakwords = split / *, */, $ENV{NOW_BREAK_WORD} if !@breakwords;
    say @breakwords . " breakwords from environment: " . join ',', @breakwords if $opts{DEBUG};
  }

  if (!@breakwords) {
    @breakwords = ( "break" );
    say @breakwords . " breakwords as default: " . join ',', @breakwords if $opts{DEBUG};
  }

  $opts{breakword} = \@breakwords;
};

setBreakword;

# say "Argv is " . join ' ', @ARGV;

sub timestampnow {
  my $t = Time::Piece->new;
  return timestamp($t);
}

sub timestamp {
  my $t = shift @_;
  return $t->date . ' ' . $t->time;
};
# say timestamp();

sub parseTimestamp { # return a localtime of timestamp
  use Try::Tiny;
  my $s = shift(@_);
  my $t;
  try {
    $t = Time::Piece->strptime($s, "%Y-%m-%d %T");
    #$t += localtime->tzoffset; # convert to localtime
  } catch {
    say "parseTimestamp: caught error $_";
    return 0;
  };
  # say "\nparseTimestamp($s) = $t = " . timestamp($t) . "\n" if $opts{DEBUG};
  should($s, timestamp($t));
  return $t;
}

# say parseTimestamp("2016-12-16 15:06:07");

my ($t1, $t2);

sub parseLine {
  my ($t2, $line) = @_;
  # say @_;
  # say "$t2, $line";
  # say timestamp($t2) . ", $line";
  if (my($timestamp, $est, $task) = $line =~ /(\d+\-\d+\-\d+ \d+:\d+:\d+) ?([\d\.-]*) (.*)/) {
    my $t1 = parseTimestamp($timestamp);
    if ($t1) {
      my $et = sprintf("%.2f", ($t2 - $t1)/3600.0);
      my @result = ($t1, $et, $est, $task);
      say "parseline(" . timestamp($t2) . ", $line)->(". join ', ', @result . ")" if $opts{DEBUG};
      return @result;
    }}
  say "parseline(" . join(', ', @_) . ")->()";
  return ();
};

sub addToTree {
  my ($tree, $et, @categories) = @_;
  # say "addToTree: " . join ', ', @{$et};
  for (@categories) {
    if (exists $tree->{$_}) {$tree = $tree->{$_};}
    else {$tree = $tree->{$_} = {};}
  }
  $tree->{''} = $et; # $et can be a list or o scalar.
};

sub printHours {
  my $arg = shift @_;
  my ($hours, $est)= @{$arg};
  
  my $output = '';
  if ($opts{"hours-minutes"}) {
    $output .= sprintf("%6d:%02d", int($hours), ($hours - int($hours))*60.0);
    if ($opts{estimates}) {
      if ($est) {
	$output .= sprintf("/%6d:%02d", int($est), ($est - int($est))*60.0);
      }
      else {
	$output .= "/ no est";
      }
    }
    $output .= " ";
    
  }
  if ($opts{minutes}) {
    $output .= sprintf("%10.0f min", $hours * 60.0);
    if ($opts{estimates}) {
      if ($est) {
	$output .= sprintf("/%10.0f min", $est * 60.0);
      }
      else {
	$output .= "/ no est";
      }
    }
    $output .= " ";
  }
  if ($opts{hours} or !$output) {
    $output .= sprintf("%8.2f hrs", $hours);
    if ($opts{estimates}) {
      if ($est) {
	$output .= sprintf("/%8.2f hrs", $est);
      }
      else {
	$output .= "/ no est";
      }
    }
    $output .= " ";
  }
  return $output;
};

      
my @output_lines; # this needs to be global, declaring it inside printReport gives scoping errs.
sub printReport {
  my $r = shift(@_);
  # say "printReport " . Dumper($r);
  @output_lines = (); # reset output lines
  sub _p {
    # my ($level, $r) = @_;
    my ($prefix, $suffix, $r) = @_;
    @_ = ();
    my $sum = 0;
    my $estsum = 0;
    # say "level = $level: " . Dumper($r);
    my @sorted_keys = reverse sort keys %{ $r };
    for my $k ( @sorted_keys ) {
      if (ref($r->{$k}) eq 'HASH') {
	if (scalar keys %{ $r->{$k} } == 1 and exists $r->{$k}->{''}) {
	  # say "Leaf category, printing hours for $suffix $k";
	  unshift @output_lines, "$prefix         " . printHours($r->{$k}->{''}) . "$suffix $k";
	  $sum += ${$r->{$k}->{''}}[0];
	  $estsum += ${$r->{$k}->{''}}[1];
	  # say "constructed leaf: sum = $sum, estsum = $estsum";
	} else {
	  # say "Aggregate category, find totals and print summary for $suffix $k";
	  my $total = _p("$prefix", "$suffix $k:", $r->{$k});
	  unshift @output_lines, "$prefix ". printHours($total) . "(total) $suffix $k";
	  $sum += ${$total}[0];
	  $estsum += ${$total}[1];
	  # say "aggregate: sum = $sum, estsum = $estsum";
	}
      } else {
	# say "True leaf, print hours for $suffix $k";
	# my $t = sprintf("%8.2f", $r->{$k});
	unshift @output_lines, "$prefix         " . printHours($r->{$k}) . "$suffix $k";
	$sum += ${$r->{$k}}[0];
	$estsum += ${$r->{$k}}[1];
	# say "leaf: sum = $sum, estsum = $estsum";
      }
    }
    return [$sum, $estsum];
  };
  # _p(0, $r);
  for my $k (reverse sort keys %{ $r }) {
    my $t = _p($k, "", $r->{$k});
    unshift @output_lines, "\n$k ". printHours($t) . "(total)";
  }
  say for @output_lines;
};

sub getVelocities { # get some velocities to simulate with
  # use the n most recent
  my $n = 1000;
  
  use File::ReadBackwards ;
  # Tied Handle Interface
  my ($t2, $et, $est, $task);
  # $t2 = localtime;
  $t2 = gmtime; $t2 += localtime->tzoffset;
  my @velocities;
  tie *BW, 'File::ReadBackwards', $opts{f} or
    die "can't read .now file ($opts{f}) $!" ;
  while( <BW> ) {
    chomp;
    if (($t2, $et, $est, $task) = parseLine($t2, $_) and $est) {
      unshift @velocities, 1.0 * $et / $est;
      last if $n-- <= 0;
    }}
  return @velocities;
}

if (@ARGV > 0) { # option parser remove options from @ARGV, check what's left
  # say "there are still arguments: " . join ', ', @ARGV;
  if ( (grep { looks_like_number($_) } @ARGV) == @ARGV ) { # test lengths
    # say "all args are numbers - Simulate";
    say "Simulating tasks of " . join(', ', @ARGV). " = " . sum(@ARGV) . " hrs total, printing percentiles . . . ";
    my @velocities = getVelocities();
    # say "velocities = " . join ',', @velocities;
    
    my @times;
    my $n = 100;
    while ($n-- > 0) {
      my $t = 0;
      for (@ARGV) { $t += $_ * $velocities[rand @velocities]; }
      unshift @times, sprintf("%6.0f", $t);
    }
    my $i = 5;
    say "     5%     15%     25%     35%     45%     55%     65%     75%     85%     95%";
    say join ', ', grep { not ( $i++ % 10 ) } sort { $a <=> $b } @times;
  } else {
    # say "NOT all args are numbers - Add a task";
    my $task = join ' ', @ARGV;
    if (!$opts{silent}) {
      my $n = 10;
      say "adding task $task, the last $n tasks in $opts{f} are:\n";
      $opts{t} = $n if (!$opts{t});
    }
    open(my $fh, '>>', $opts{f}) or die "Could not open file '$opts{f}' $!";
    say $fh timestampnow() . " " . $task;
    close $fh; 
  }
}

if ($opts{t} || $opts{d} || $opts{w} || $opts{y}) { # print report of tasks
  use File::ReadBackwards ;
  # Tied Handle Interface

  if ($opts{t}) { # task report
    my ($t1, $t2, $et, $est, $task);
    $t2 = gmtime; $t2 += localtime->tzoffset;
    say "first t2 = $t2 = ". timestamp($t2) if $opts{DEBUG};
    my @output_lines = ();
    tie *BW, 'File::ReadBackwards', $opts{f} or
      die "can't read .now file ($opts{f}) $!" ;
    while( <BW> ) {
      chomp;
      say if $opts{DEBUG};
      if (($t1, $et, $est, $task) = parseLine($t2, $_)) {
	say timestamp($t1) . "=t1=$t1, $et, $est, $task - ". timestamp($t1)  if $opts{DEBUG};
	my $line = timestamp($t1) . " for ".printHours([$et,$est])." $task";
	$t2 = $t1;
	say $line if $opts{DEBUG};
	say "" if $opts{DEBUG};
	unshift @output_lines, $line;
	last if --$opts{t} <= 0;
      }}
    say for @output_lines;
  }

  sub generateReport {
    my ($field, $n) = @_;
    my @processed_lines; # store processed lines here for verbose option
    my %report;
    tie *BW, 'File::ReadBackwards', $opts{f} or
      die "can't read .now file ($opts{f}) $!" ;
    my $t2 = localtime; # gmtime; //  + localtime->tzoffset;
    while( <BW> ) {
      chomp;
      if (my ($nextt2, $et, $est, $task) = parseLine($t2, $_)) {
	if ($opts{verbose}) { unshift @processed_lines, "$t2 $et $est $task"; }
	$t2 = $nextt2;
	# if we're processing a break, skip it.
	next if !$opts{nobreak} and grep /^$task$/, @{$opts{breakword}};
	my $r;
	if (exists $report{$t2->$field}) {
	  $r = $report{$t2->$field};
	  # say $t2->$field . " exists.";
	}
	else {
	  # say $t2->$field . " does not exist.";
	  last if $n-- <= 0;
	  $r = $report{$t2->$field} = {};
	}
	my @categories = split /\s*:+\s*/, $task;
	addToTree( $r, [$et, $est], @categories );
	# say Dumper(\%report);
      }}
    if ($opts{verbose}) { say for @processed_lines; say ""; }
    printReport(\%report);
  }

  if ($opts{d}) { # daily report
    # say "daily";
    generateReport("date", $opts{d});
  }
  if ($opts{w}) { # weekly report
    # say "weekly";

    generateReport(\&getWeek, $opts{w});
  }
  if ($opts{y}) { # yearly report
    generateReport("year", $opts{y});
  }
};

sub getWeek {
  # http://perldoc.perl.org/Time/Piece.html#Week-Number: The week
  # number may be an unknown concept to some readers. The ISO 8601
  # standard defines that weeks begin on a Monday and week 1 of the
  # year is the week that includes both January 4th and the first
  # Thursday of the year. In other words, if the first Monday of
  # January is the 2nd, 3rd, or 4th, the preceding days of the January
  # are part of the last week of the preceding year. Week numbers
  # range from 1 to 53.
  my $t = shift @_;
  return $t->year . " week " . $t->week . " beginning " .
    ($t - ($t->_wday-1) * ONE_DAY)->date;
};
      


__END__

=head1 now EXAMPLES

B<now prog: docs>      # Add task "prog: docs" to .now file.

B<now 12 prog: plan>   # Add task "prog: plan" with estimate 12 minutes.

B<now>                 # Print report.

B<now -t 4>            # Print report of the last 4 tasks

B<now -d 4>            # Print report of the last 4 days.

B<now -w 4>            # Print report of the last 4 weeks.

B<now 5>               # Estimate duration of task estimated to be 5 minutes.

B<now 5 10 3>          # Estimate the duration of tasks estimated to be 
                    # 5, 10, and 3 hours.

sample - Using GetOpt::Long and Pod::Usage

=head1 SYNOPSIS

sample [options] [file ...]

 Options:
   -h|?              brief help message
   --help | --man    full documentation
   --version         print version and exit
   --verbose | -v    print processed lines before reports
   --hours           print report in hours (default)
   --minutes         print report in minutes instead of hours
   --hours-minutes   print report in hours and minutes instead of hours
   --nobreak         do not skip breaks
   --breakword stop  use "stop" as the breakword instead of "break".
   --estimates       show estimates when reporting
   --noestimates     turn off estimates when reporting
   -f mynowfile      use now file mynowfile (default is ~/.now)
   -t 5              show 5 tosks
   -d 5              show 5 days
   -w 5              show 5 weeks

=head1 OPTIONS

=over 4

=item B<-h>

Print a brief help message and exits.

=item B<--help>

Prints the manual page and exits.

=item B<--breakword stop>

Use "stop" as the breakword instead of the default or the environment-defined breakword.
Multiple words can be defined by separating with commas or using multiple --breakword options.
The default breakword is "break".
The default breakword can be set by the environment variable "NOW_BREAK_WORD".

=back

=head1 DESCRIPTION

B<now> is a simple, text-based, shell-based time tracker suitable for 
tracking time at the terminal and completing time sheets. 
Tasks are stored in a text file ~/Dropbox/.now or ~/.now.
Tasks are stored in the .now file, one task per line, prepended by a timestamp and 
an optional estimate (in hours). You can easily edit this file by hand. This utility just 
makes common tasks easier.

B<now> has three modes of use: 
(1) real-time tracking mode, 
(2) report mode, and 
(3) estimation mode.

To use the real-time tracking mode, call B<now> with the task. 
The task will be appended the .now file with the current time.
Call B<now> with a new task, or a "break" task when the current task is done.

=over 4

now programming: finish docs # start tracking "programming: docs" now

=back

You can also add an estimate (integer). 

=over 4

now 10 my task # start tracking "my task" now, estimate 10 minutes

=back

Use the -d, -w, or -t options for report mode. This will print a report of the last n days, weeks, or tasks respectively. Colons (:) are used to mark task categories. Reports break down time spent hierachially in each category and task. The -v or --verbose option will print the tasks processed before the report.

Calling B<now> with a list of estimates will produce a time range based on past estimates in the now file. 

=head1 CUSTOMIZATION

=item B<.now>

To customize the .now file, set the NOW_FILE environment variable or use the -f flag. 
Specifically, add the following line to your ~/.profile: 

=over 4

export NOW_FILE=~/.now

=back

=item B<breakword>

To customize the break word, add the following line to you ~/.profile:

=over 4

export NOW_BREAK_WORD=stop,break,quit,done

=back

=item B<estimates>

To set estimates on automatically, add the following line to you ~/.profile:

=over 4

export NOW_ESTIMATES=1

=back



=cut
